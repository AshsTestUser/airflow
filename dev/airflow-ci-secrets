#!/usr/bin/env python3

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import io
import os
import shlex
import subprocess
import re
import tempfile

try:
    import click
    import encrypteddict
    import gpgme
    import yaml
except ImportError as e:
    exit(f"Could not find the {e.name} library. Run 'pip install '.[devel_ci]'` to install.")


# The "airflow-github-actions" private key needs to be made available inside a Secret in Github Actions. To create this key use the following commands:
#
#    install -d --mode 700 airflow-gpg-temp
#    gpg --homedir=airflow-gpg-temp --passphrase '' --batch --quick-gen-key 'Airflow Github Actions <airflow-github-actions@invalid>' futuredefault
#    gpg --homedir=airflow-gpg-temp --armor --export-secret-keys airflow-github-actions@invalid > airflow-github-actions.priv
#    gpg --homedir=airflow-gpg-temp --armor --export-keys airflow-github-actions@invalid > airflow-github-actions.pub
#
# The contents of the .priv key should be placed in a Github secret, and the .pub file should be updated here.c

CI_PUB_KEY = '''
-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEXqBILhYJKwYBBAHaRw8BAQdAWYxxHs/AKvl9e/QjePBqyCZFMta/SmR8rcpC
IgzQ+Zm0N0FpcmZsb3cgR2l0aHViIEFjdGlvbnMgPGFpcmZsb3ctZ2l0aHViLWFj
dGlvbnNAaW52YWxpZD6IlgQTFggAPhYhBC9WcDUeAGkO74hDf1dw8YcvVEhABQJe
oEguAhsDBQkDwmcABQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAAAoJEFdw8YcvVEhA
Yt0A/2ka8AFfp2IIKiPJnaPZ7ol/pGEhdp3lLhfMQvlrGItXAP0Ty9SCoWVLnYZE
lIUMY01F5nXmoJ9SebyD4TLC8qTtAbg4BF6gSC4SCisGAQQBl1UBBQEBB0AHLbst
+QtQBmaTg+pHTY64Sadxk0cgU2gaoTWtNF4ifwMBCAeIeAQYFggAIBYhBC9WcDUe
AGkO74hDf1dw8YcvVEhABQJeoEguAhsMAAoJEFdw8YcvVEhAYgEA/RAlo2fdMTH0
wUAlgnqJx7paD0r75Q8ORUkrtKed9bC2AP95hMSONNxZ+OqWxffFk7kL2jCa1oKg
GAaiR/oUdo71Dw==
=Yp0l
-----END PGP PUBLIC KEY BLOCK-----
'''

RECIPIENT_KEY_IDS = (
    # When adding to this list:
    # 1. Just adding to the list will not make previous values available to the new recipients
    # 2. Only use long ids (40 characters in length, not 8 or 16.)
    # 3. Put a comment saying which user the ID belongs to.

    # Airflow Github Actions <airflow-github-actions@invalid>
    '2F5670351E00690EEF88437F5770F1872F544840',

    # Ash Berlin-Taylor <ash@apache.org>
    '5CCAEAC758ED64CA323F053B807C731A8C82A095',
)

SECRETS_FILE = os.path.normpath(os.path.join(__file__, '..', '..', '.github', 'secrets.yaml'))

class Recrypter(encrypteddict.crypter):

    PATTERN = re.compile(r'ENC\[.*,.*\]')

    def decrypt_gpg_match_for_edit(self, value):
        return f'DEC::(GPG)[{self.decrypt_match_group(value)}]'

    def decrypt_all_for_edit(self, decrypt_this):
        """
        A decryption mode that leaves in place the markers so that it will re-encrypt the same values.
        """
        if type(decrypt_this) == str:
            return self.PATTERN.sub(self.decrypt_gpg_match_for_edit, decrypt_this)
        return self.decrypt_all(decrypt_this)

    def encrypt_all(self, encrypt_this, recipients=None):
        # Don't encrypt anything before the first document marker. This is to preserve the inital doc-comment without encrypting the value
        separator = '---\n'
        if isinstance(encrypt_this, str):
            pos = encrypt_this.find(separator)
            if pos != -1:
                return encrypt_this[0:pos + len(separator)] + super().encrypt_all(encrypt_this[pos + len(separator):], recipients)
        return super().encrypt_all(encrypt_this, recipients)

    def encrypt_gpg(self, value, recipients):
        # BugFix against upstream encrypteddict: it returns bytes, so was formatting wrong
        __import__('pdb').set_trace()
        val = super().encrypt_gpg(value, recipients)
        if isinstance(val, bytes):
            return val.decode('utf-8')
        return val


@click.group()
def cli():
    r"""
    This tool allows editing, setting, or getting secrets from GPG-encrypted files
    """


def _get_editor():
    # Try to find the users configured editor, favouring a GUI editor, and then falling back to vi
    editor = os.environ.get('VISUAL', os.environ.get('EDITOR', 'vi'))
    return shlex.split(editor)


@cli.command()
def reencrypt():
    """
    Re-encrypt all encrypted values in the file

    Under normal circumstances, the `edit` command will not re-encrypt values
    if they don't change (to reduce git-diff) but you can use `--decrypt-all`
    flag to edit the file with the values in place.
    """


@cli.command()
@click.option('--decrypt-all', help='Decrypt all values in place for editing and re-encryption', is_flag=True)
def edit(decrypt_all):
    """
    Open the file for editing, and encrypt decorated values on editor close.

    This will need at least the CI public key added (`import-ci-pubkey` command), and all other

    This will attempt to decrypt the secrets file, then open it in an editor,
    and when saved-and-closed re-encrypt it.
    """
    crypter = Recrypter()
    with open(SECRETS_FILE, 'r') as fh:
        enc = fh.read()
        if decrypt_all:
            decrypted = crypter.decrypt_all_for_edit(enc)
        else:
            decrypted = enc

    # Keep one named file around, so we can re-edit it in case of yaml or encryption error
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.yaml', prefix='airflow-secrets-') as dangerous:
        dangerous.write(decrypted)
        dangerous.flush()

        try:
            subprocess.check_call(_get_editor() + [dangerous.name])
        except subprocess.CalledProcessError:
            exit(1)

        # Re-read the file and encrypt it
        dangerous.seek(0, os.SEEK_SET)
        decrypted = dangerous.read()

        while True:
            enc = crypter.encrypt_all(decrypted, RECIPIENT_KEY_IDS)
            # Check YAML syntax is valid
            try:
                dict = yaml.safe_load(enc)

                # Check if it's a "flat" dict - nothing more than strings as values!
                for key, val in dict.items():
                    if not isinstance(val, str):
                        raise ValueError(f'Only string values are allowed, {key!r} was {type(val)} ')

                # File is valid YAML, and valid  stop trying to edit
                break
            except yaml.YAMLError as e:
                click.echo(click.style('There was a YAML syntax error\n', fg='red'))
                click.echo(click.style(str(e), fg='red'))

                if not click.confirm(click.style("Edit again?", fg='yellow'), default="Y"):
                    return
            except ValueError as e:
                click.echo(click.style(str(e), fg='red'))

                if not click.confirm(click.style("Edit again?", fg='yellow'), default="Y"):
                    return

        with open(SECRETS_FILE, 'w') as fh:
            fh.write(enc)


@cli.command()
@click.option('--for-github', help='Output', is_flag=True)
@click.option(
    '--import-privkey-from-env',
    metavar='ENV_VAR_NAME',
    help='Import the private key from the named environment var into a temporary GPG Home dir for decryption'
)
def export(for_github=False, import_privkey_from_env=None):
    """
    Produce bash-evalable output to set all secrets in the file.

    If `--for-github` is true then the value will be masked from Github logs,
    and also use the special syntax to set the value for all downstream jobs

    """

    gpghome = None
    if import_privkey_from_env:
        print(repr(os.environ))
        gpghome = tempfile.TemporaryDirectory(prefix='airflow-gpg-home')
        crypter = Recrypter(gpg_home=gpghome.name)

        result = crypter.ctx.import_(io.BytesIO(os.environ[import_privkey_from_env].encode('ascii')))
        if result.imported != 1:
            click.echo(click.style('Error importing GPG Private key', style='red'), err=True)
            click.echo(click.style(repr(_gpg_import_result_to_dict(result)), style='red'), err=True)
            exit(1)

        for key in crypter.ctx.keylist():
            print(key.uids[0].name)

    else:
        crypter = Recrypter()

    with open(SECRETS_FILE, 'r') as fh:
        enc = yaml.safe_load(fh)
        decrypted = crypter.decrypt_all(enc)

        for (key, val) in decrypted.items():
            print(f'export {key}={shlex.quote(val)};')
            if for_github:
                # https://help.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable
                click.echo(f'echo "::add-mask::${key}";')
                click.echo(f'echo "::set-env name={key}::{val}";')

    if gpghome:
        gpghome.cleanup()


def _gpg_import_result_to_dict(result):
    return {
        attr: getattr(result, attr) for attr in dir(result) if not attr.startswith('__')
    }


@cli.command()
def import_ci_pubkey():
    """
    Import the GPG public key in to your GPG keyring; needed for adding new encrypted values
    """
    ctx = gpgme.Context()
    result = ctx.import_(io.BytesIO(CI_PUB_KEY.encode('ascii')))

    if result.unchanged > 0:
        click.echo('Key already imported to GPG keyring')
    elif result.imported > 0:
        click.echo('Key imported to GPG keyring')
    else:
        debug = {
            attr: getattr(result, attr) for attr in dir(result) if not attr.startswith('__')
        }
        click.echo(click.style('Error importing gpg key!', fg="red"))
        click.echo(repr(debug))

    ...

@cli.command()
def missing_recipient_key_ids():
    """
    Print the Key IDs that are missing from the GPG public key ring.
    """

    ctx = gpgme.Context()

    missing = []
    for key_id in RECIPIENT_KEY_IDS:
        if not any(ctx.keylist(f'0x{key_id}')):
            missing.append(f'0x{key_id}')

    if missing:
        click.echo('Missing key ids:\n')
        for key_id in missing:
            click.echo(key_id)
    else:
        click.echo(click.style('All keys present', fg='green'))

if __name__ == "__main__":
    cli()
